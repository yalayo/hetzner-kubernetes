name: Infrastructure

on:
  push:
    branches: [ master ]
  #workflow_dispatch:

jobs:
  infrastructure:
    name: Create/Update sever
    runs-on: ubuntu-latest

    outputs:
      nodes_ips: ${{ steps.terraform.outputs.nodes_ips }}
      first_node_ip: ${{ steps.terraform.outputs.first_node_ip }}
    
    steps:
      - uses: actions/checkout@v3
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
      - name: Deploy with Terraform
        id: terraform
        env:
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_k3s_token: ${{ secrets.K3S_TOKEN }}
        run: |
            cd ./terraform
            terraform init

            # Run plan with detailed exit code: 0 = no changes, 2 = changes to apply
            set +e
            terraform plan -out=planned.tfplan -detailed-exitcode
            PLAN_EXIT_CODE=$?
            set -e

            CHANGED=false

            if [ "$PLAN_EXIT_CODE" -eq 2 ]; then
              echo "Resource changes detected; applying."
              terraform apply -auto-approve planned.tfplan
              CHANGED=true
            elif [ "$PLAN_EXIT_CODE" -eq 0 ]; then
              echo "No resource changes according to exit code 0; checking for output-only changes."

              # Try to render the plan as JSON
              if ! terraform show -json planned.tfplan > plan.json 2>show_err.txt; then
                echo "ERROR: 'terraform show -json' failed. stderr:"
                cat show_err.txt
                exit 1
              fi

              # Validate JSON
              if ! jq empty plan.json >/dev/null 2>&1; then
                echo "ERROR: plan.json is not valid JSON; dumping beginning of file for inspection:"
                head -n 200 plan.json
                exit 1
              fi

              # Count output changes (fallback to 0 if missing)
              OUTPUT_CHANGES=$(jq '.output_changes // {} | length' plan.json)
              if [ "$OUTPUT_CHANGES" -gt 0 ]; then
                echo "Output-only changes detected ($OUTPUT_CHANGES); applying to refresh outputs."
                terraform apply -auto-approve planned.tfplan
                CHANGED=true
              else
                echo "No changes to apply (neither resources nor outputs)."
              fi
            else
              echo "Terraform plan failed with exit code $PLAN_EXIT_CODE" >&2
              exit $PLAN_EXIT_CODE
            fi

            # Extract JSON array from mixed output
            NODES_IPS_JSON=$(terraform output -json nodes_ips 2>/dev/null | grep -oP '\[(?:"[^"]*",?)+\]' | head -n1)
            FIRST_NODE_IP=$(terraform output -raw first_node_ip 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1)
            FIRST_NODE_INTERNAL_IP=$(terraform output -raw first_node_internal_ip 2>/dev/null | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1)

            echo $FIRST_NODE_IP
            # Export as job outputs
            echo "nodes_ips=$NODES_IPS_JSON" >> "$GITHUB_OUTPUT"
            echo "first_node_ip=$FIRST_NODE_IP" >> "$GITHUB_OUTPUT"
            echo "first_node_internal_ip=$FIRST_NODE_INTERNAL_IP" >> "$GITHUB_OUTPUT"
            echo "changed=$CHANGED" >> "$GITHUB_OUTPUT"

  deploy-primary:
    name: Install NixOS/k3s on the main node
    needs: infrastructure
    if: needs.infrastructure.outputs.changed == 'true'
    runs-on: ubuntu-latest
    env:
      # fallback if needed; better to pass per-step when required
      NIX_PATH: nixpkgs=channel:nixos-24.11
      K3S_TOKEN: ${{ secrets.K3S_TOKEN }}  # export so builtins.getEnv can see it during evaluation
    steps:
      - uses: actions/checkout@v3
      - name: Cache Nix store (optional speedup)
        uses: actions/cache@v4
        with:
          path: /nix/store
          key: nix-store-${{ runner.os }}-${{ github.sha }}
          # note: caching /nix/store can be huge; adjust strategy if too large
      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v10
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes
      - name: Prepare SSH key and config
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_nixos_anywhere
          chmod 600 ~/.ssh/id_nixos_anywhere

          ssh-keyscan -H "${{ needs.infrastructure.outputs.first_node_ip }}" >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Install NixOS remotely
        env:
          K3S_TOKEN: ${{ secrets.K3S_TOKEN }}
        run: |
          set -euo pipefail
          IP=${{ needs.infrastructure.outputs.first_node_ip }}
          echo "Deploying to $IP (cluster-init=${{ matrix.is_init }})"

          # Some redundancy
          #export K3S_TOKEN="${{ secrets.K3S_TOKEN }}"

          nix run github:nix-community/nixos-anywhere -- \
            --flake './nix/main/nixos#prod-main' \
            --generate-hardware-config nixos-generate-config ./hardware-configuration.nix \
            --option k3s.token "${K3S_TOKEN}" \
            --extra-files ./nix/main \
            --build-on remote \
            --no-root-password \
            --target-host "root@$IP" \
            -i ~/.ssh/id_nixos_anywhere

  # deploy:
  #   name: Install NixOS/k3s on secodary nodes in parallel
  #   needs: deploy-primary
  #   runs-on: ubuntu-latest
  #   env:
  #     # fallback if needed; better to pass per-step when required
  #     NIX_PATH: nixpkgs=channel:nixos-24.11
  #   strategy:
  #     matrix:
  #       node_ip: ${{ fromJson(needs.infrastructure.outputs.nodes_ips) }}
  #   steps:
  #     - uses: actions/checkout@v3
  #     - name: Debug received nodes_ips
  #       run: |
  #         echo "Internal IP: '${{ needs.infrastructure.outputs.first_node_internal_ip }}'"
  #     - name: Cache Nix store (optional speedup)
  #       uses: actions/cache@v4
  #       with:
  #         path: /nix/store
  #         key: nix-store-${{ runner.os }}-${{ github.sha }}
  #         # note: caching /nix/store can be huge; adjust strategy if too large
  #     - name: Install Nix
  #       uses: DeterminateSystems/nix-installer-action@v10
  #       with:
  #         extra_nix_config: |
  #           experimental-features = nix-command flakes
  #     - name: Determine if init
  #       run: |
  #         if [ "${{ matrix.node_ip }}" = "${{ needs.infrastructure.outputs.first_node_ip }}" ]; then
  #           IS_INIT=true
  #         else
  #           IS_INIT=false
  #         fi
  #         echo "is_init=$IS_INIT" >> "$GITHUB_OUTPUT"
  #       id: determine_init
  #     - name: Prepare SSH key and config
  #       run: |
  #         set -euo pipefail
  #         mkdir -p ~/.ssh
  #         echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_nixos_anywhere
  #         chmod 600 ~/.ssh/id_nixos_anywhere

  #         ssh-keyscan -H "${{ matrix.node_ip }}" >> ~/.ssh/known_hosts
  #         chmod 600 ~/.ssh/known_hosts

  #         echo "Writing k3s token to remote using explicit identity file"
  #         ROLE_CONTENT="https://${{ needs.infrastructure.outputs.first_node_internal_ip }}:6443"

  #         # Base64 encode token
  #         TOKEN_B64=$(printf '%s' "${{ secrets.K3S_TOKEN }}" | base64 -w0)

  #         # Write token and role file on remote
  #         ssh -i ~/.ssh/id_nixos_anywhere \
  #             -o StrictHostKeyChecking=no \
  #             -o IdentitiesOnly=yes \
  #             -o UserKnownHostsFile=/dev/null \
  #             root@"${{ matrix.node_ip }}" <<'EOF_REMOTE'
  #               printf '%s' "$TOKEN_B64" | base64 -d > /etc/k3s-token
  #               chmod 600 /etc/k3s-token

  #               # Role file: "init" for first node, otherwise the server URL to join
  #               echo '${ROLE_CONTENT}' > /etc/k3s-role
  #             EOF_REMOTE

  #     - name: Install NixOS remotely
  #       run: |
  #         set -euo pipefail
  #         IP=${{ matrix.node_ip }}
  #         echo "Deploying to $IP (cluster-init=${{ matrix.is_init }})"

  #         # Add later --k3s-extra-args "${EXTRA_FLAGS}" \
  #         nix run github:nix-community/nixos-anywhere -- \
  #           --flake './nixos#prod-secondary' \
  #           --generate-hardware-config nixos-generate-config ./hardware-configuration.nix \
  #           --option k3s.token ${{ secrets.K3S_TOKEN }} \
  #           --extra-files ./nixos \
  #           --build-on remote \
  #           --no-root-password \
  #           --target-host "root@$IP" \
  #           -i ~/.ssh/id_nixos_anywhere