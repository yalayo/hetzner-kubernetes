name: Infrastructure

on:
  push:
    branches: [ master ]
  #workflow_dispatch:

jobs:
  infrastructure:
    name: Create/Update sever
    runs-on: ubuntu-latest
    outputs:
      nodes_ips: ${{ steps.terraform.outputs.nodes_ips }}
      first_node_ip: ${{ steps.terraform.outputs.first_node_ip }}
    env:
      # fallback if needed; better to pass per-step when required
      NIX_PATH: nixpkgs=channel:nixos-24.11
    steps:
      - uses: actions/checkout@v3
      - name: Cache Nix store (optional speedup)
        uses: actions/cache@v4
        with:
          path: /nix/store
          key: nix-store-${{ runner.os }}-${{ github.sha }}
          # note: caching /nix/store can be huge; adjust strategy if too large
      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@v10
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
      - name: Deploy with Terraform
        env:
          TF_VAR_hcloud_token: ${{ secrets.HCLOUD_TOKEN }}
          TF_VAR_ssh_private_key: ${{ secrets.SSH_PRIVATE_KEY }}
          TF_VAR_k3s_token: ${{ secrets.K3S_TOKEN }}
        run: |
            cd ./terraform
            terraform init
            terraform apply -auto-approve

            # Show all outputs (helps catch if the output name is wrong)
            echo "Full terraform JSON outputs:"

            # Grab the specific one
            NODES_IPS_JSON=$(terraform output -raw nodes_ips | grep -oE '([0-9]{1,3}\.){3}[0-9]{1,3}' | head -n1)

            # Debug visibility (delimited so you can spot stray characters)
            echo "Raw nodes_ips JSON: <<<${NODES_IPS_JSON}>>>"

            # Validate it's proper JSON; if not, dump hex and fail
            if ! echo "$NODES_IPS_JSON" | jq . >/dev/null 2>&1; then
              echo "ERROR: nodes_ips output is not valid JSON; aborting." >&2
              printf 'Content hex dump:\n'
              printf '%s' "$NODES_IPS_JSON" | hexdump -C
              exit 1
            fi

            # Expect terraform to output a JSON array of nodes IPs called nodes_ips
            NODES_IPS_JSON=$(terraform output -json nodes_ips)
            echo "NODES_IPS_JSON<<EOF" >> "$GITHUB_ENV"
            echo "$NODES_IPS_JSON" >> "$GITHUB_ENV"
            echo "EOF" >> "$GITHUB_ENV"

            # Extract first node separately for cluster-init and reference
            FIRST_NODE_IP=$(echo "$NODES_IPS_JSON" | jq -r '.[0]')
            echo "FIRST_NODE_IP=$FIRST_NODE_IP" >> $GITHUB_ENV

            # Export as job outputs (new syntax)
            # Safely set outputs (JSON needs heredoc form)
            echo "nodes_ips<<EOF" >> "$GITHUB_OUTPUT"
            echo "$NODES_IPS_JSON" >> "$GITHUB_OUTPUT"
            echo "EOF" >> "$GITHUB_OUTPUT"
            echo "first_node_ip=$FIRST_NODE_IP" >> "$GITHUB_OUTPUT"

      - name: Prepare SSH key and config for nixos-anywhere
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          # Write private key to file
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_nixos_anywhere
          chmod 600 ~/.ssh/id_nixos_anywhere

          echo "Nodes JSON: $NODES_IPS_JSON"
          for ip in $(echo "$NODES_IPS_JSON" | jq -r '.[]'); do
            ssh-keyscan -H "$ip" >> ~/.ssh/known_hosts
          done
          chmod 600 ~/.ssh/known_hosts

      - name: Seed k3s token on target
        run: |
          set -euo pipefail
          echo "Writing k3s token to remote using explicit identity file"
          # Base64 encode locally so we can safely transmit arbitrary token content
          TOKEN_B64=$(printf '%s' "${{ secrets.K3S_TOKEN }}" | base64 -w0)

          for ip in $(echo "$NODES_IPS_JSON" | jq -r '.[]'); do
            echo "Writing k3s token to $ip"
            ssh -o StrictHostKeyChecking=no root@"$ip" \
              "printf '%s' '${TOKEN_B64}' | base64 -d > /etc/k3s-token && chmod 600 /etc/k3s-token"
          done

  deploy:
    name: Install NixOS/k3s on masters in parallel
    needs: infrastructure
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - node_ip: ${{ fromJson(needs.infrastructure.outputs.nodes_ips)[0] }}
            is_init: true
          - node_ip: ${{ fromJson(needs.infrastructure.outputs.nodes_ips)[1] }}
            is_init: false
          - node_ip: ${{ fromJson(needs.infrastructure.outputs.nodes_ips)[2] }}
            is_init: false
    steps:
      - uses: actions/checkout@v3

      - name: Prepare SSH key and config
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_nixos_anywhere
          chmod 600 ~/.ssh/id_nixos_anywhere

          ssh-keyscan -H "${{ matrix.node_ip }}" >> ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Install NixOS remotely
        run: |
          set -euo pipefail
          IP=${{ matrix.node_ip }}
          echo "Deploying to $IP (cluster-init=${{ matrix.is_init }})"

          EXTRA_FLAGS=""
          if [ "${{ matrix.is_init }}" = "true" ]; then
            EXTRA_FLAGS="--cluster-init"
          else
            EXTRA_FLAGS="--server https://${{ needs.infrastructure.outputs.first_node_ip }}:6443"
          fi

          nix run github:nix-community/nixos-anywhere -- \
            --flake './nixos#prod-node' \
            --generate-hardware-config nixos-generate-config ./hardware-configuration.nix \
            --option k3s.token ${{ secrets.K3S_TOKEN }} \
            --build-on remote \
            --no-root-password \
            --target-host "root@${IP}" \
            -i ~/.ssh/id_nixos_anywhere \
            --k3s-extra-args "${EXTRA_FLAGS}"